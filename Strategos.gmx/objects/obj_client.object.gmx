<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>0</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//socket setup

host_socket = network_create_socket(network_socket_tcp);
is_connected = network_connect(host_socket, global.ip, global.port);
write_buffer = buffer_create(params.buffer_size, buffer_fixed, 1); 
latency = 0;

//gui setup

enemy_tiles = scr_type_count_array();
move_animation_waiting = 0; //0 = not waiting, 1 = waiting for initial move, 2 = waiting for combat animation, 3 = waiting for death animation, 4 = waiting for two death animations
spot_waiting = 0;
turn_waiting = 0;
placed = 0;
sel_x = 0;
sel_y = 0;

for (var i = 9; i &gt;= 0; --i) {
    for (var j = 7; j &gt;= 0; --j) {
        board[i, j] = noone;
    }
}
//create our side's pieces
var inst = instance_create(scr_type_pos_x(tile_type.flag    , 0), scr_type_pos_y(tile_type.flag        , 0), obj_base_tile); inst.type = tile_type.flag; //flag
inst = instance_create(scr_type_pos_x(tile_type.spy         , 0), scr_type_pos_y(tile_type.spy         , 0), obj_base_tile); inst.type = tile_type.spy; //spy
inst = instance_create(scr_type_pos_x(tile_type.spotter_1   , 0), scr_type_pos_y(tile_type.spotter_1   , 0), obj_base_tile); inst.type = tile_type.spotter_1; //spotter 1
inst = instance_create(scr_type_pos_x(tile_type.spotter_1   , 1), scr_type_pos_y(tile_type.spotter_1   , 1), obj_base_tile); inst.type = tile_type.spotter_1; //spotter 2
inst = instance_create(scr_type_pos_x(tile_type.scout_2     , 0), scr_type_pos_y(tile_type.scout_2     , 0), obj_base_tile); inst.type = tile_type.scout_2; //scout 1
inst = instance_create(scr_type_pos_x(tile_type.scout_2     , 1), scr_type_pos_y(tile_type.scout_2     , 1), obj_base_tile); inst.type = tile_type.scout_2; //scout 2
inst = instance_create(scr_type_pos_x(tile_type.scout_2     , 2), scr_type_pos_y(tile_type.scout_2     , 2), obj_base_tile); inst.type = tile_type.scout_2; //scout 3
inst = instance_create(scr_type_pos_x(tile_type.scout_2     , 3), scr_type_pos_y(tile_type.scout_2     , 3), obj_base_tile); inst.type = tile_type.scout_2; //scout 4
inst = instance_create(scr_type_pos_x(tile_type.scout_2     , 4), scr_type_pos_y(tile_type.scout_2     , 4), obj_base_tile); inst.type = tile_type.scout_2; //scout 5
inst = instance_create(scr_type_pos_x(tile_type.miner_3     , 0), scr_type_pos_y(tile_type.miner_3     , 0), obj_base_tile); inst.type = tile_type.miner_3; //miner 1
inst = instance_create(scr_type_pos_x(tile_type.miner_3     , 1), scr_type_pos_y(tile_type.miner_3     , 1), obj_base_tile); inst.type = tile_type.miner_3; //miner 2
inst = instance_create(scr_type_pos_x(tile_type.miner_3     , 2), scr_type_pos_y(tile_type.miner_3     , 2), obj_base_tile); inst.type = tile_type.miner_3; //miner 3
inst = instance_create(scr_type_pos_x(tile_type.miner_3     , 3), scr_type_pos_y(tile_type.miner_3     , 3), obj_base_tile); inst.type = tile_type.miner_3; //miner 4
inst = instance_create(scr_type_pos_x(tile_type.miner_3     , 4), scr_type_pos_y(tile_type.miner_3     , 4), obj_base_tile); inst.type = tile_type.miner_3; //miner 5
inst = instance_create(scr_type_pos_x(tile_type.sergeant_4  , 0), scr_type_pos_y(tile_type.sergeant_4  , 0), obj_base_tile); inst.type = tile_type.sergeant_4; //4 1
inst = instance_create(scr_type_pos_x(tile_type.sergeant_4  , 1), scr_type_pos_y(tile_type.sergeant_4  , 1), obj_base_tile); inst.type = tile_type.sergeant_4; //4 2
inst = instance_create(scr_type_pos_x(tile_type.lieutenant_5, 0), scr_type_pos_y(tile_type.lieutenant_5, 0), obj_base_tile); inst.type = tile_type.lieutenant_5; //5 1
inst = instance_create(scr_type_pos_x(tile_type.lieutenant_5, 1), scr_type_pos_y(tile_type.lieutenant_5, 1), obj_base_tile); inst.type = tile_type.lieutenant_5; //5 2
inst = instance_create(scr_type_pos_x(tile_type.captain_6   , 0), scr_type_pos_y(tile_type.captain_6   , 0), obj_base_tile); inst.type = tile_type.captain_6; //6 1
inst = instance_create(scr_type_pos_x(tile_type.captain_6   , 1), scr_type_pos_y(tile_type.captain_6   , 1), obj_base_tile); inst.type = tile_type.captain_6; //6 2
inst = instance_create(scr_type_pos_x(tile_type.major_7     , 0), scr_type_pos_y(tile_type.major_7     , 0), obj_base_tile); inst.type = tile_type.major_7; //7
inst = instance_create(scr_type_pos_x(tile_type.colonel_8   , 0), scr_type_pos_y(tile_type.colonel_8   , 0), obj_base_tile); inst.type = tile_type.colonel_8; //8
inst = instance_create(scr_type_pos_x(tile_type.general_9   , 0), scr_type_pos_y(tile_type.general_9   , 0), obj_base_tile); inst.type = tile_type.general_9; //9
inst = instance_create(scr_type_pos_x(tile_type.marshal_10  , 0), scr_type_pos_y(tile_type.marshal_10  , 0), obj_base_tile); inst.type = tile_type.marshal_10; //10
inst = instance_create(scr_type_pos_x(tile_type.bomb        , 0), scr_type_pos_y(tile_type.bomb        , 0), obj_base_tile); inst.type = tile_type.bomb; //bomb 1
inst = instance_create(scr_type_pos_x(tile_type.bomb        , 1), scr_type_pos_y(tile_type.bomb        , 1), obj_base_tile); inst.type = tile_type.bomb; //bomb 2
inst = instance_create(scr_type_pos_x(tile_type.bomb        , 2), scr_type_pos_y(tile_type.bomb        , 2), obj_base_tile); inst.type = tile_type.bomb; //bomb 3
inst = instance_create(scr_type_pos_x(tile_type.bomb        , 3), scr_type_pos_y(tile_type.bomb        , 3), obj_base_tile); inst.type = tile_type.bomb; //bomb 4
inst = instance_create(scr_type_pos_x(tile_type.bomb        , 4), scr_type_pos_y(tile_type.bomb        , 4), obj_base_tile); inst.type = tile_type.bomb; //bomb 5
inst = instance_create(scr_type_pos_x(tile_type.bomb        , 5), scr_type_pos_y(tile_type.bomb        , 5), obj_base_tile); inst.type = tile_type.bomb; //bomb 6

//create null blocks
board[2,3] = instance_create(0,0, obj_base_tile); board[2,3].owner = 2; instance_deactivate_object(board[2,3]);
board[2,4] = instance_create(0,0, obj_base_tile); board[2,4].owner = 2; instance_deactivate_object(board[2,4]);
board[3,3] = instance_create(0,0, obj_base_tile); board[3,3].owner = 2; instance_deactivate_object(board[3,3]);
board[3,4] = instance_create(0,0, obj_base_tile); board[3,4].owner = 2; instance_deactivate_object(board[3,4]);
board[6,3] = instance_create(0,0, obj_base_tile); board[6,3].owner = 2; instance_deactivate_object(board[6,3]);
board[6,4] = instance_create(0,0, obj_base_tile); board[6,4].owner = 2; instance_deactivate_object(board[6,4]);
board[7,3] = instance_create(0,0, obj_base_tile); board[7,3].owner = 2; instance_deactivate_object(board[7,3]);
board[7,4] = instance_create(0,0, obj_base_tile); board[7,4].owner = 2; instance_deactivate_object(board[7,4]);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>network_destroy(host_socket);
buffer_delete(write_buffer);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="56">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>with (obj_base_tile) {
    if (grabbed==true) {
    
        var temp_grid_x = round((x-params.board_offset_x)/params.board_grid_size);
        var temp_grid_y = round((y-params.board_offset_y)/params.board_grid_size);
    
        grabbed = false;
        depth = 0; //default, typically transitions to sliding with -10 depth after this
        if (state == 0 || state==1) {
            if (temp_grid_x &gt;= 0 &amp;&amp; temp_grid_x &lt;= 9 &amp;&amp; temp_grid_y &gt;=5 &amp;&amp; temp_grid_y &lt;= 7) {
                var ref = other.board[temp_grid_x, temp_grid_y];
                
                if (ref!=noone &amp;&amp; ref!=self) { //need to remove previous occupant (it's not us)
                    if (state == 1) other.board[grid_x, grid_y] = ref; //put it in our old location
                    with (ref) {
                        if (other.state == 0) { //send it back to starting location
                            state = 0;
                            scr_slide(xstart,ystart,-8); //slide under our new tile, but over everything else
                        } else { //just do the slide and grid location update, it remains in state 1
                            grid_x = other.grid_x;
                            grid_y = other.grid_y;
                            scr_slide(params.board_offset_x + grid_x*params.board_grid_size, params.board_offset_y + grid_y*params.board_grid_size, -8);
                        }
                    }
                } else if (state == 1 &amp;&amp; other.board[temp_grid_x, temp_grid_y]!=self) { //need to clear previous assignment
                    other.board[grid_x, grid_y] = noone;
                } else if (ref==noone) {
                    other.placed += 1; //this is the normal case, and the only one where the number of placed items changes
                    if (other.placed == 30) instance_create(params.submit_x, params.submit_y, obj_button_submit); //full board means we can submit
                };
      
                grid_x = temp_grid_x;
                grid_y = temp_grid_y;
                
                other.board[grid_x, grid_y] = self;
                state = 1; //in place, not locked
                
                scr_slide(params.board_offset_x + grid_x*params.board_grid_size, params.board_offset_y + grid_y*params.board_grid_size);
            } else if (state == 0) { //just move it back to where it came from
                scr_slide(xstart, ystart);
            } else { //if (state == 1) { //move it back to the set grid position. board data hasn't changed. default case should always be state 1
                scr_slide(params.board_offset_x + grid_x*params.board_grid_size, params.board_offset_y + grid_y*params.board_grid_size);
            }
        } 
    } else if (active) { //player may be making a move
        var temp_grid_x = round((x-params.board_offset_x)/params.board_grid_size);
        var temp_grid_y = round((y-params.board_offset_y)/params.board_grid_size);
        
        if (temp_grid_x != grid_x || temp_grid_y != grid_y) {
            global.turn = false; //prevent future tile moves, even if we might give a spot/no-spot option
            if (type == tile_type.spotter_1 &amp;&amp; other.board[temp_grid_x, temp_grid_y]== noone &amp;&amp; temp_grid_y &gt;= 1 &amp;&amp; other.board[temp_grid_x, temp_grid_y-1]!= noone &amp;&amp; other.board[temp_grid_x, temp_grid_y-1].owner==1){ //spotter was moved into an EMPTY position that it may spot from
                selected = true;
                other.sel_x = grid_x;
                other.sel_y = grid_y;
                instance_create(params.spot_x, params.spot_y, obj_button_spot);
                instance_create(params.nospot_x, params.nospot_y, obj_button_nospot);
            } else { //impossible for a spot action to be taken, go ahead and submit
                scr_submit_move(grid_x, grid_y, temp_grid_x, temp_grid_y);
            }
        } else if (can_spot) { //we selected the spotter, so present the option to spot without moving
            selected = true;
            other.sel_x = grid_x;
            other.sel_y = grid_y;
            instance_create(params.spot_x, params.spot_y, obj_button_spot);
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="68">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var v_event_type = ds_map_find_value(async_load, "type");
switch(v_event_type){
    case network_type_data:
        var read_buffer = ds_map_find_value(async_load, "buffer");
        var socket = ds_map_find_value(async_load, "id");
        buffer_seek(read_buffer, buffer_seek_start, 0);
        scr_client_incoming_packets(read_buffer, socket);

    break;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
